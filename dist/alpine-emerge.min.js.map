{
  "version": 3,
  "sources": ["../src/index.js", "../builds/browser.js"],
  "sourcesContent": ["export default function (Alpine) {\n  // The directive\n  Alpine.directive('emerge', async (el, { value, expression }, { effect, evaluateLater }) => {\n    // Sink...\n    if (!_D) {\n      return\n    }\n\n    const root = el.content.firstElementChild\n    const cid = root.getAttribute('emerge-cid')\n    const extra = root.getAttribute('emerge-extra')\n\n    // Lazy load component when the if-statement\n    // expression evaluates to a truthy value or\n    // the for-statement has at least one loop.\n    if (cid && value === 'if') {\n      const evaluator = evaluateLater(expression)\n\n      // Evaluate `if`\n      effect(() => {\n        evaluator((evaluated) => {\n          if (evaluated) {\n            resolve()\n          }\n        })\n      })\n    } else if (cid && value === 'for') {\n      const items = parseForExpression(expression).items\n      const evaluator = evaluateLater(items)\n\n      // Evaluate `for`\n      effect(() => {\n        evaluator((evaluated) => {\n          if (\n            (typeof evaluated === 'number' && evaluated > 0) ||\n            (typeof evaluated === 'object' && evaluated.length > 0)\n          ) {\n            resolve()\n          }\n        })\n      })\n    } else {\n      resolve()\n    }\n\n    /**\n     * Emerge the component with Underscored and swap the `<template>`\n     * directives.\n     *\n     * @returns A promise when the component is emerged\n     */\n    async function resolve() {\n      if (cid) {\n        await _D.emerge(cid, root, extra ? JSON.parse(extra) : undefined)\n      }\n\n      el.removeAttribute(`x-emerge:${value}`)\n      setTimeout(() => el.setAttribute(`x-${value}`, expression))\n    }\n  })\n\n  /**\n   * Parse an expression of a for-statement.\n   * This was taken from VueJS 2.* core. Thanks Vue!\n   *\n   * @param {string} expression The for-expression\n   * @returns {object} An Alpine `for` object\n   */\n  function parseForExpression(expression) {\n    let forIteratorRE = /,([^,\\}\\]]*)(?:,([^,\\}\\]]*))?$/\n    let stripParensRE = /^\\s*\\(|\\)\\s*$/g\n    let forAliasRE = /([\\s\\S]*?)\\s+(?:in|of)\\s+([\\s\\S]*)/\n    let inMatch = expression.match(forAliasRE)\n\n    if (!inMatch) return\n\n    let res = {}\n    res.items = inMatch[2].trim()\n    let item = inMatch[1].replace(stripParensRE, '').trim()\n    let iteratorMatch = item.match(forIteratorRE)\n\n    if (iteratorMatch) {\n      res.item = item.replace(forIteratorRE, '').trim()\n      res.index = iteratorMatch[1].trim()\n\n      if (iteratorMatch[2]) {\n        res.collection = iteratorMatch[2].trim()\n      }\n    } else {\n      res.item = item\n    }\n\n    return res\n  }\n}\n", "import emerge from '../src/index.js'\n\ndocument.addEventListener('alpine:init', () => window.Alpine.plugin(emerge))\n"],
  "mappings": "MAAe,WAAU,EAAQ,CAE/B,EAAO,UAAU,SAAU,MAAO,EAAI,CAAE,QAAO,cAAc,CAAE,SAAQ,mBAAoB,CAEzF,GAAI,CAAC,GACH,OAGF,GAAM,GAAO,EAAG,QAAQ,kBAClB,EAAM,EAAK,aAAa,YAAY,EACpC,EAAQ,EAAK,aAAa,cAAc,EAK9C,GAAI,GAAO,IAAU,KAAM,CACzB,GAAM,GAAY,EAAc,CAAU,EAG1C,EAAO,IAAM,CACX,EAAU,AAAC,GAAc,CACvB,AAAI,GACF,EAAQ,CAEZ,CAAC,CACH,CAAC,CACH,SAAW,GAAO,IAAU,MAAO,CACjC,GAAM,GAAQ,EAAmB,CAAU,EAAE,MACvC,EAAY,EAAc,CAAK,EAGrC,EAAO,IAAM,CACX,EAAU,AAAC,GAAc,CACvB,AACG,OAAO,IAAc,UAAY,EAAY,GAC7C,MAAO,IAAc,UAAY,EAAU,OAAS,IAErD,EAAQ,CAEZ,CAAC,CACH,CAAC,CACH,KACE,GAAQ,EASV,kBAAyB,CACvB,AAAI,GACF,KAAM,IAAG,OAAO,EAAK,EAAM,EAAQ,KAAK,MAAM,CAAK,EAAI,MAAS,EAGlE,EAAG,gBAAgB,YAAY,GAAO,EACtC,WAAW,IAAM,EAAG,aAAa,KAAK,IAAS,CAAU,CAAC,CAC5D,CACF,CAAC,EASD,WAA4B,EAAY,CACtC,GAAI,GAAgB,iCAChB,EAAgB,iBAChB,EAAa,qCACb,EAAU,EAAW,MAAM,CAAU,EAEzC,GAAI,CAAC,EAAS,OAEd,GAAI,GAAM,CAAC,EACX,EAAI,MAAQ,EAAQ,GAAG,KAAK,EAC5B,GAAI,GAAO,EAAQ,GAAG,QAAQ,EAAe,EAAE,EAAE,KAAK,EAClD,EAAgB,EAAK,MAAM,CAAa,EAE5C,MAAI,GACF,GAAI,KAAO,EAAK,QAAQ,EAAe,EAAE,EAAE,KAAK,EAChD,EAAI,MAAQ,EAAc,GAAG,KAAK,EAE9B,EAAc,IAChB,GAAI,WAAa,EAAc,GAAG,KAAK,IAGzC,EAAI,KAAO,EAGN,CACT,CACF,CC5FA,SAAS,iBAAiB,cAAe,IAAM,OAAO,OAAO,OAAO,CAAM,CAAC",
  "names": []
}
